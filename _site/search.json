[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Anubhav’s blog",
    "section": "",
    "text": "Movie Genre Predictions with Hugging Face Transformers\n\n\n\n\n\nMy attempt on the Movie Genre Predictions competition\n\n\n\n\n\n\nSep 6, 2023\n\n\nAnubhav Maity\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Me",
    "section": "",
    "text": "Hey, I’m Anubhav Maity, a ML Engineer at Expedia Group. My day job involves training, deploying, and keeping an eye on ML models for fraud detection.\nOutside of my job, I immerse myself in NLP and Deep Learning through coursework, participation in Kaggle competitions, and reading of research papers, with a particular focus on Generative AI Models.\nJoin me on this blog as I share my ML experiences and insights. Let’s explore the world of AI and data together.\nThanks for stopping by!"
  },
  {
    "objectID": "posts/movie_genre_prediction_using_hf_transformer/index.html",
    "href": "posts/movie_genre_prediction_using_hf_transformer/index.html",
    "title": "Movie Genre Predictions with Hugging Face Transformers",
    "section": "",
    "text": "Install the following packages by uncommenting the following if not installed already\n\n# !pip install datasets\n# !pip install transformers -U\n# !pip install huggingface_hub\n# !pip install rich\n# !pip install accelerate -U\n# !pip install evaluate\n\nFollowing are the steps to create hugging face credentials token which be needed when using notebook_login below\n\nCreate a Hugging Face account (if you don’t have one): If you don’t already have an account on the Hugging Face website, you’ll need to create one. Visit the Hugging Face website (https://huggingface.co/) and sign up for an account.\nLog in to your Hugging Face account: Use your credentials to log in to your Hugging Face account.\nGenerate an API token: Hugging Face provides API tokens for authentication. To generate an API token, go to your account settings on the Hugging Face website. You can usually find this in your account dashboard or profile settings.\nGenerate the token: Once you’re in your account settings, look for an option related to API tokens or credentials. You should find an option to generate a new token. Click on it, and the system will generate a unique API token for you.\nCopy the API token: Once the token is generated, you’ll typically see it displayed on the screen. It might be a long string of characters. Copy this token to your clipboard.\nStore the token securely: API tokens are sensitive credentials, so it’s essential to store them securely. You should never share your API token publicly or expose it in your code repositories.\n\nNow, you have your Hugging Face API token, which you can use for authentication when making requests to the Hugging Face API or accessing resources on the Hugging Face Model Hub.\n\nfrom huggingface_hub import notebook_login\n\nnotebook_login()\n\n\n\n\nLets import the following pacakges\n\nfrom transformers import TrainingArguments, Trainer, AutoTokenizer, AutoModelForSequenceClassification\nfrom datasets import load_dataset\nfrom collections import Counter\nimport evaluate\nimport numpy as np\nfrom rich import print\nimport pandas as pd\n\n\n\nWe will be using the datadrivenscience/movie-genre-prediction competition dataset for model training. You can read more about the competition here and the dataset here.\n\ndataset = load_dataset(\"datadrivenscience/movie-genre-prediction\"); dataset\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDatasetDict({\n    train: Dataset({\n        features: ['id', 'movie_name', 'synopsis', 'genre'],\n        num_rows: 54000\n    })\n    test: Dataset({\n        features: ['id', 'movie_name', 'synopsis', 'genre'],\n        num_rows: 36000\n    })\n})\n\n\nThe dataset has train and test splits with following features - id - movie name - synopsis - genre\n\nprint(dataset['train'][:3])\n\n{\n    'id': [44978, 50185, 34131],\n    'movie_name': ['Super Me', 'Entity Project', 'Behavioral Family Therapy for Serious Psychiatric Disorders'],\n    'synopsis': [\n        'A young scriptwriter starts bringing valuable objects back from his short nightmares of being chased by a \ndemon. Selling them makes him rich.',\n        'A director and her friends renting a haunted house to capture paranormal events in order to prove it and \nbecome popular.',\n        'This is an educational video for families and family therapists that describes the Behavioral Family \nTherapy approach to dealing with serious psychiatric illnesses.'\n    ],\n    'genre': ['fantasy', 'horror', 'family']\n}\n\n\n\nAbove we have sliced and printed 3 rows of training dataset\n\nlabels = set(dataset['train']['genre'])\nnum_labels = len(labels)\nlabels\n\n{'action',\n 'adventure',\n 'crime',\n 'family',\n 'fantasy',\n 'horror',\n 'mystery',\n 'romance',\n 'scifi',\n 'thriller'}\n\n\nThere are 10 genres, - action - adventure - crime - family - fantasy - horror - mystery - romance - scifi - thriller\n\nlabels_count = Counter(dataset['train']['genre']); print(labels_count)\n\nCounter({\n    'fantasy': 5400,\n    'horror': 5400,\n    'family': 5400,\n    'scifi': 5400,\n    'action': 5400,\n    'crime': 5400,\n    'adventure': 5400,\n    'mystery': 5400,\n    'romance': 5400,\n    'thriller': 5400\n})\n\n\n\nLooks like the labels are evenly sampled, everyone has count of 5400. Thats good.\n\n\n\n\ncheckpoint = \"bert-base-uncased\"\n\nA checkpoint is a saved model state, including its architecture and trained weights, which can be used for various NLP tasks and fine-tuning.\n\ntokenizer = AutoTokenizer.from_pretrained(checkpoint)\ntokenizer('Movie Genre Predictions with Hugging Face Transformers')\n\n{'input_ids': [101, 3185, 6907, 20932, 2007, 17662, 2227, 19081, 102], 'token_type_ids': [0, 0, 0, 0, 0, 0, 0, 0, 0], 'attention_mask': [1, 1, 1, 1, 1, 1, 1, 1, 1]}\n\n\nAbove we load the tokenizer and use it on a sentence. Loading a checkpoint of a tokenizer associated with a pretrained language model is necessary to maintain consistency in the tokenization process. This ensures that your input text is processed in a way that aligns with the model’s pre-existing knowledge and allows you to use the pretrained model effectively\nWhat is attention_mask? > Sometimes, we want to tell the computer which parts of the sentence are important and which are not. The attention mask is like a spotlight. It’s a list of 1s and 0s, where 1 means “pay attention” and 0 means “ignore.” For our sentence, it could be [1, 1, 1, 1, 1] because we want the computer to pay attention to all tokens.\nWhat is token_type_ids? > If you have multiple sentences, you’d want the computer to know which sentence each token belongs to. Token Type IDs help with that. For one sentence, it’s all 0s. If you had two sentences, the first sentence would have 0s, and the second sentence would have 1s.\nLet’s break down the process of creating input_ids below into following steps:\n\n\nImagine you have a sentence, “Hugging Face is awesome!” To help a computer understand it, you first split it into smaller parts, like words: [“Hugging”, “Face”, “is”, “awesome”, “!”]. These smaller parts are called tokens.\nWe can tokenize the synopsis of the first row of training set\n\ndataset['train'][0]['synopsis']\n\n'A young scriptwriter starts bringing valuable objects back from his short nightmares of being chased by a demon. Selling them makes him rich.'\n\n\n\ntokens = tokenizer.tokenize(dataset['train'][0]['synopsis']); tokens\n\n['a',\n 'young',\n 'script',\n '##writer',\n 'starts',\n 'bringing',\n 'valuable',\n 'objects',\n 'back',\n 'from',\n 'his',\n 'short',\n 'nightmares',\n 'of',\n 'being',\n 'chased',\n 'by',\n 'a',\n 'demon',\n '.',\n 'selling',\n 'them',\n 'makes',\n 'him',\n 'rich',\n '.']\n\n\n\n\n\nComputers prefer numbers, so we need to convert these tokens into unique numbers. Each token gets a special ID. For example, “Hugging” might be ID 101, “Face” might be ID 102, and so on. The sentence becomes a list of IDs: [101, 102, 103, 104, 105].\n\nids = tokenizer.convert_tokens_to_ids(tokens); ids\n\n[1037,\n 2402,\n 5896,\n 15994,\n 4627,\n 5026,\n 7070,\n 5200,\n 2067,\n 2013,\n 2010,\n 2460,\n 15446,\n 1997,\n 2108,\n 13303,\n 2011,\n 1037,\n 5698,\n 1012,\n 4855,\n 2068,\n 3084,\n 2032,\n 4138,\n 1012]\n\n\nIn summary, Hugging Face tokenization takes your text, breaks it into tokens (smaller parts), gives each token a unique ID, creates an attention mask to say what’s important, and token type IDs to track different sentences if needed.\n\ndataset = dataset.rename_column('genre', 'labels')\n\n\ndataset = dataset.class_encode_column(\"labels\")\n\n\n\n\n\n\n\n\nds = dataset[\"train\"].train_test_split(test_size=0.2, stratify_by_column=\"labels\")\n\n\nds\n\nDatasetDict({\n    train: Dataset({\n        features: ['id', 'movie_name', 'synopsis', 'labels'],\n        num_rows: 43200\n    })\n    test: Dataset({\n        features: ['id', 'movie_name', 'synopsis', 'labels'],\n        num_rows: 10800\n    })\n})\n\n\n\ndef tokenize(sample):\n    sample[\"labels\"] = dataset[\"train\"].features[\"labels\"].str2int(sample[\"labels\"])\n    return tokenizer(sample['synopsis'], truncation=True)\n\n\ntokenized_ds = ds.map(tokenize, batched=True); tokenized_ds\n\nDatasetDict({\n    train: Dataset({\n        features: ['id', 'movie_name', 'synopsis', 'labels', 'input_ids', 'token_type_ids', 'attention_mask'],\n        num_rows: 43200\n    })\n    test: Dataset({\n        features: ['id', 'movie_name', 'synopsis', 'labels', 'input_ids', 'token_type_ids', 'attention_mask'],\n        num_rows: 10800\n    })\n})\n\n\n\ntokenized_test_ds = dataset[\"test\"].map(tokenize, batched=True); tokenized_test_ds\n\n\n\n\nDataset({\n    features: ['id', 'movie_name', 'synopsis', 'labels', 'input_ids', 'token_type_ids', 'attention_mask'],\n    num_rows: 36000\n})\n\n\nThe above code tokenizes the dataset’s synopsis feature using the tokenize function in a batch wise manner\n\n\n\n\n\ntraining_args = TrainingArguments('movie-genre-predictions', \n                                  evaluation_strategy = 'epoch',\n                                  per_device_train_batch_size = 32,\n                                  per_device_eval_batch_size = 64,\n                                  save_strategy = 'epoch',\n                                  push_to_hub = True\n                                 )\n\nThe above code sets up the configuration for training a Hugging Face model, for a movie genre prediction task. Let’s break it down step by step:\n\nTrainingArguments: This is a special object or data structure that holds various settings and options for training a machine learning model.\n'movie-genre-predictions': It’s naming the training process or giving it a unique name. It’s like giving a name to a file so you can easily identify it later.\nevaluation_strategy = 'epoch': This line specifies how often the model’s performance should be evaluated. In this case, it’s set to ‘epoch,’ which means after every complete pass through the training data. An epoch is like a full round of training.\nper_device_train_batch_size = 32: This indicates how many examples or data points should be processed at once on each processing unit during training. It’s set to 32, so 32 data points will be processed together in parallel.\nper_device_eval_batch_size = 64: Similar to the previous line, but this one specifies the batch size for evaluation (measuring how well the model is doing). It’s set to 64, so 64 examples will be evaluated at once.\nsave_strategy = 'epoch': This determines when the model’s checkpoints (saves of the model’s progress) should be saved. Again, it’s set to ‘epoch,’ meaning after each training round.\npush_to_hub = True: This is likely specific to the Hugging Face Transformers library. If set to ‘True,’ it means that the model checkpoints will be pushed or uploaded to the Hugging Face Model Hub, a place to store and share models.\n\nIn simple terms, this code is configuring how a machine learning model should be trained for movie genre prediction. It sets up details like when to check how well the model is doing, how much data to process at a time, and where to save the model’s progress. It also says that the model checkpoints should be uploaded to the Hugging Face Model Hub.\nYou may see more details about TrainingArguments here\n\nmodel = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels = num_labels)\n\nSome weights of BertForSequenceClassification were not initialized from the model checkpoint at bert-base-uncased and are newly initialized: ['classifier.bias', 'classifier.weight']\nYou should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.\n\n\nAbove we load the model for Sequence Classification of 10 labels\n\nclf_metrics = evaluate.load(\"accuracy\")\n\nThe evaluate library provides the metrics on which to evaluate the validation set. Above I have choosen accuracy as the metrics\n\ndef compute_metrics(batch):\n    logits, labels = batch\n    predictions = np.argmax(logits, axis=-1)\n    return clf_metrics.compute(predictions=predictions, references=labels)\n\nI have defined compute_metrics to compute the metrics after each epoch on validation set\n\ntrainer = Trainer(model, \n                  args = training_args,\n                  train_dataset = tokenized_ds['train'],\n                  eval_dataset = tokenized_ds['test'], \n                  tokenizer = tokenizer,\n                  compute_metrics = compute_metrics\n                 )\n\nThe Trainer function in Hugging Face simplifies the process of fine-tuning pre-trained NLP models for specific tasks. It handles data loading, training, evaluation, and model saving, making it easier to customize and use these models for various NLP tasks.\n\ntrainer.train()\n\n\n\n    \n      \n      \n      [4050/4050 09:22, Epoch 3/3]\n    \n    \n  \n \n      Epoch\n      Training Loss\n      Validation Loss\n      Accuracy\n    \n  \n  \n    \n      1\n      0.283500\n      3.311370\n      0.317315\n    \n    \n      2\n      1.029200\n      2.257011\n      0.325463\n    \n    \n      3\n      0.676700\n      2.709101\n      0.312685\n    \n  \n\n\n\nTrainOutput(global_step=4050, training_loss=0.6523225073166835, metrics={'train_runtime': 562.6496, 'train_samples_per_second': 230.339, 'train_steps_per_second': 7.198, 'total_flos': 3860478233326848.0, 'train_loss': 0.6523225073166835, 'epoch': 3.0})\n\n\n\n\n\n\ntest_logits = trainer.predict(tokenized_test_ds)\n\n\n\n\n\ntest_logits.predictions.shape\n\n(36000, 10)\n\n\n\ntest_predictions = np.argmax(test_logits.predictions, axis=-1)\n\n\npredicted_genre = dataset[\"train\"].features[\"labels\"].int2str(test_predictions)\n\n\ndf = pd.DataFrame({'id':tokenized_test_ds['id'],\n                  'genre': predicted_genre})\n\n\ndf.to_csv('submission.csv')"
  }
]